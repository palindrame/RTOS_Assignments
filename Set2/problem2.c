/*
Let there be two matrices A (n X m) and B (m X p). The product matrix C = A x B will be a n X p matrix where C[i,j], 1 ≤ i ≤ n, 1 ≤ j ≤ p  =  ith row of A . jth column of B = 

Write a complete user-friendly C program that reads two matrices A (n X m) and B (m X p) from the user in arrays  a[ ][ ] and b[ ][ ], respectively. The program then creates n number of child processes such that each of these child processes computes one unique row of the product matrix C and saves that in the corresponding row of an array c[ ][ ]. For example, the 1st child process may compute the 1st row, that is, the elements  C[1,1],  C[1,2], ..., C[1,p] and stores them in c[0][0], c[0][1], ..., c[0][p-1], respectively;  the 2nd child process may compute C[2,1], C[2,2], ..., C[2,p]  and stores them in c[1][0], c[1][1],, ..., c[1][p-1], and so on. Please note that the array c[ ][ ] has to be shared among  all of n (child) + 1 (parent) processes.

After all the child processes finish putting corresponding values in c[ ][ ], the parent process prints c[ ][ ] in the matrix form.


Your program(s) should arrange to release the shared memory that has been created during execution.

As enhancement of this assignment (not to be submitted today), we may conceive that this program has to be used for a series of such multiplications of matrices (of different sizes) to be done by a collection of cooperating processes.  That is, neither the parent process nor any of the child processes terminates after one such matrix multiplication. They can be reused to compute product matrix as long as the user desires. You have to propose and implement a scheme for this. 
*/

#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>
#include <sys/types.h>
#include <stdio.h>
#include <sys/shm.h>
#include <signal.h>

void controlSHM(int);

int main () {

  int shmid;
  pid_t pid;
  int sharedArray[]; // the shared variable

  shmid = shmget(IPC_PRIVATE, sizeof(int), IPC_CREAT | 0777);

  if (shmid == -1) {
    perror("Error in shmget()!\n");
    exit(1);
  }

  sharedNum = shmat(shmid, NULL, 0);

  if(sharedNum == (int*)-1) {
    perror("Error in shmat()!\n");
    exit(1);
  }

  pid = fork();

  if (pid == 0) {
    signal(SIGUSR1, controlSHM); // to "catch" the signal received from the parent
    while(1) {
      pause(); // to "wait" till a signal is received from the parent i.e. wait till the parent updates the value
      printf("(Child) the number received from the parent is: %d\n", *sharedNum);
      int factorial = *sharedNum;
      calculateFactorial(*sharedNum, &factorial);
      printf("(Child) factorial calculated for %d is: %d\n", *sharedNum, factorial);
      *sharedNum = factorial; // value updation by the child
      kill(getppid(), SIGUSR2); // let the parent know that the value has been updated by the child
    }
  }

  else {
    while(1) {
      signal(SIGUSR2, controlSHM); // to "catch" the signal received from the child
      int randomNumber;
      randomNumber = rand() % 10 + 1;
      printf("(Parent) the randomNumber generated by the parent is: %d\n", randomNumber);
      *sharedNum = randomNumber; // value updation by the parent
      kill(pid, SIGUSR1); // let the child know that the parent has updated the shared memory
      pause(); // to "wait" till a signal from the child is received
      printf("(Parent) factorial received from child is: %d\n", *sharedNum);

    }
  }

  wait(NULL);

  if (shmdt(sharedNum) == -1) {
    perror("Error in shmdt()!\n");
    exit(1);
  }

  if (shmctl(shmid, IPC_RMID, NULL) == -1) {
    perror("Error in shmctl()!\n");
    exit(1);
  }

  return 0;
}

void controlSHM (int signum) {
  if (signum == SIGUSR1) {
    //handle child
  }

  else if (signum == SIGUSR2) {
    //handle parent
  }
}



