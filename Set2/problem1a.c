/*

Let there be a (parent) process which goes on putting a random (integer) number  in a shared variable, say n,  in a regular interval. There is a child process that goes on putting the factorial of the integer (that it finds in n) back into the shared variable (n), in regular intervals. The parent process prints the factorial that it receives from the child process. Device your own mechanism(s) so that the child process "knows" that a new number has been put in n  by the parent process and the parent process "knows" that a the factorial of a number has been put in n  by the child  process,

Write a complete C program to implement the above. The program should make arrangements for releasing shared memory that has been created during execution.

The processes must print meaningful output so that the user understands what is happening.

*/



#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>
#include <sys/types.h>
#include <stdio.h>
#include <sys/shm.h>
#include <signal.h>

void calculateFactorial(int num, int* result);
void controlSHM(int);

int main () {

  int shmid;
  pid_t pid;
  int* sharedNum; // the shared variable

  shmid = shmget(IPC_PRIVATE, sizeof(int), IPC_CREAT | 0777);

  if (shmid == -1) {
    perror("Error in shmget()!\n");
    exit(1);
  }

  sharedNum = shmat(shmid, NULL, 0);

  if(sharedNum == (int*)-1) {
    perror("Error in shmat()!\n");
    exit(1);
  }

  pid = fork();

  if (pid == 0) {
    signal(SIGUSR1, controlSHM); // to "catch" the signal received from the parent
    while(1) {
      pause(); // to "wait" till a signal is received from the parent i.e. wait till the parent updates the value
      printf("(Child) the number received from the parent is: %d\n", *sharedNum);
      int factorial = *sharedNum;
      calculateFactorial(*sharedNum, &factorial);
      printf("(Child) factorial calculated for %d is: %d\n", *sharedNum, factorial);
      *sharedNum = factorial; // value updation by the child
      kill(getppid(), SIGUSR2); // let the parent know that the value has been updated by the child
    }
  }

  else {
    while(1) {
      signal(SIGUSR2, controlSHM); // to "catch" the signal received from the child
      int randomNumber;
      randomNumber = rand() % 10 + 1;
      printf("(Parent) the randomNumber generated by the parent is: %d\n", randomNumber);
      *sharedNum = randomNumber; // value updation by the parent
      kill(pid, SIGUSR1); // let the child know that the parent has updated the shared memory
      pause(); // to "wait" till a signal from the child is received
      printf("(Parent) factorial received from child is: %d\n", *sharedNum);

    }
  }

  wait(NULL);

  if (shmdt(sharedNum) == -1) {
    perror("Error in shmdt()!\n");
    exit(1);
  }

  if (shmctl(shmid, IPC_RMID, NULL) == -1) {
    perror("Error in shmctl()!\n");
    exit(1);
  }

  return 0;
}

void controlSHM (int signum) {
  if (signum == SIGUSR1) {
    //handle child
  }

  else if (signum == SIGUSR2) {
    //handle parent
  }
}

void calculateFactorial (int num, int* result) {
  *result = 1;
  for(int i = 1; i <= num; i++) {
    *result *= i;
  }
}

